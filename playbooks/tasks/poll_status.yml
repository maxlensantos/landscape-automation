---
# tasks/poll_status.yml

- name: Check Juju status
  ansible.builtin.command: sg lxd -c "juju status --format=json"
  register: juju_status_json
  changed_when: false
  ignore_errors: true

- name: Safely parse Juju status JSON
  ansible.builtin.set_fact:
    juju_status_data: "{{ juju_status_json.stdout | from_json }}"
  register: parse_result
  failed_when: false
  when: juju_status_json.stdout is defined and juju_status_json.stdout != ""

- name: Parse status and identify issues
  when: parse_result is succeeded and juju_status_data is defined
  block:
    - name: "Check cluster health with a robust Python script"
      ansible.builtin.command:
        cmd: "python3 -c '\nimport json, sys;\nstdin_content = sys.stdin.read();\nif not stdin_content: sys.exit(1);\ntry:\n    status = json.loads(stdin_content);\n    apps = status.get(\"applications\", {});\n    if not apps: sys.exit(1);\n    for app_name, app_data in apps.items():\n        if not app_data.get(\"units\"): continue;\n        app_status = app_data.get(\"application-status\", {}).get(\"current\");\n        if app_status != \"active\":\n            sys.exit(1);\n    sys.exit(0);\nexcept Exception:\n    sys.exit(1);\n        '"
        stdin: "{{ juju_status_json.stdout }}"
      register: health_check_result
      changed_when: false
      failed_when: false

    - name: "Set completion fact based on Python script result"
      ansible.builtin.set_fact:
        all_apps_active: "{{ health_check_result.rc == 0 }}"

    - name: Identify units in error state
      ansible.builtin.set_fact:
        error_units: "{{ error_units_as_string | from_yaml }}"
      vars:
        error_units_as_string: |
          {% set units = [] %}
          {% set status = juju_status_json.stdout | from_json %}
          {% set apps = status.get('applications', {}) %}
          {% for app_name, app_data in apps.items() %}
            {% if app_data.units is defined %}
              {% for unit_name, unit_data in app_data.units.items() %}
                {% if unit_data.get('workload-status', {}).get('current', '') == 'error' %}
                  {% set _ = units.append({
                    'name': unit_name, 
                    'message': unit_data.get('workload-status', {}).get('message', ''),
                    'app': app_name
                  }) %}
                {% endif %}
              {% endfor %}
            {% endif %}
          {% endfor %}
          {{ units | to_yaml }}
      when: not (health_check_result.rc == 0)

- name: Attempt to resolve units in error state
  when: 
    - not all_apps_active
    - error_units is defined
    - error_units | length > 0
    - retry_num > 30
    - retry_num is divisibleby 20
  block:
    - name: Log error units being resolved
      ansible.builtin.debug:
        msg: "Tentando resolver unidade com erro: {{ item.name }} ({{ item.message }})"
      loop: "{{ error_units }}"
      loop_control:
        label: "{{ item.name }}"

    - name: Resolve HAProxy SSL certificate error specifically
      ansible.builtin.command: "sg lxd -c 'juju resolved {{ item.name }}'"
      loop: "{{ error_units }}"
      loop_control:
        label: "{{ item.name }}"
      when: "'certificate' in item.message or 'hook failed' in item.message"
      changed_when: true
      register: resolve_result
      failed_when: false

    - name: Wait brief moment after resolve
      ansible.builtin.pause:
        seconds: 5
      when: resolve_result.changed

- name: Display live Juju status
  when: not all_apps_active
  ansible.builtin.debug:
    msg: |
      ######################################################################
      #  AGUARDANDO CLUSTER (TENTATIVA {{ retry_num }}/{{ max_iterations }}) - Timeout em ~{{ ((max_iterations - retry_num) * 5 / 60) | round }} min  #
      ######################################################################

      {{ juju_status_json.stdout }}

- name: Pause for 5 seconds between checks
  when: not all_apps_active
  ansible.builtin.pause:
    seconds: 5