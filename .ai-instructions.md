Instruções para AI Coder: Landscape Server HA Automation
Objetivo Final
Automatizar deploy de Landscape Server em 3 containers LXD com:

✅ FQDN: landscap.poc.serpro
✅ Port forwarding automático (6554, 443, 80)
✅ Cloud-init para provisionamento
✅ Acesso sem intervenção manual


Fase 1: Deploy Single Landscape (MVP)
Task 1.1: Cloud-Init Setup
Automation Goal: Passar cloud-init.yaml diretamente ao lxc launch
Playbook Requirements:
yaml- name: "Download cloud-init official template"
  ansible.builtin.get_url:
    url: https://raw.githubusercontent.com/canonical/landscape-scripts/main/provisioning/cloud-init-quickstart.yaml
    dest: /tmp/cloud-init.yaml

- name: "Configure cloud-init variables"
  ansible.builtin.replace:
    path: /tmp/cloud-init.yaml
    regexp: "{% set {{ item.key }} = '.*' %}"
    replace: "{% set {{ item.key }} = '{{ item.value }}' %}"
  loop:
    - { key: "EMAIL", value: "admin@poc.serpro" }
    - { key: "HOSTNAME", value: "landscap" }
    - { key: "DOMAIN", value: "poc.serpro" }
    - { key: "TIMEZONE", value: "America/Sao_Paulo" }
    - { key: "LANDSCAPE_VERSION", value: "24.04" }
    - { key: "TOKEN", value: "" }

- name: "Launch container with cloud-init"
  ansible.builtin.shell: |
    lxc delete landscape --force 2>/dev/null || true
    sleep 5
    lxc launch ubuntu:24.04 landscape --config=user.user-data="$(cat /tmp/cloud-init.yaml)"
  become: yes

- name: "Wait for cloud-init completion (300s timeout)"
  ansible.builtin.shell: |
    for i in {1..60}; do
      if lxc exec landscape -- test -f /var/lib/cloud/instance/boot-finished 2>/dev/null; then
        echo "Cloud-init complete"
        exit 0
      fi
      echo "Waiting... ($i/60)"
      sleep 5
    done
    exit 1
  become: yes
  timeout: 350

Fase 2: Port Forwarding Automation
Task 2.1: Get Container IP
yaml- name: "Get Landscape container IP"
  ansible.builtin.shell: |
    lxc list landscape --format csv -c 4 | head -1
  register: landscape_ip
  become: yes

- name: "Debug: Show IP"
  ansible.builtin.debug:
    msg: "Landscape IP: {{ landscape_ip.stdout }}"
Task 2.2: Configure Port Forwarding
yaml- name: "Configure LXD port forwarding"
  ansible.builtin.shell: |
    LANDSCAPE_IP="{{ landscape_ip.stdout }}"
    
    # Remove existing proxies
    for PORT in 6554 443 80; do
      lxc config device remove landscape tcp${PORT}proxyv4 2>/dev/null || true
    done
    
    # Add new proxies
    for PORT in 6554 443 80; do
      lxc config device add landscape tcp${PORT}proxyv4 \
        proxy listen=tcp:0.0.0.0:${PORT} connect=tcp:${LANDSCAPE_IP}:${PORT}
    done
  become: yes
  register: port_forward_result

- name: "Verify port forwarding"
  ansible.builtin.debug:
    msg: |
      ✅ Port Forwarding Configured:
      - Local 6554 → Container 6554
      - Local 443 → Container 443
      - Local 80 → Container 80

Fase 3: FQDN + DNS Configuration
Task 3.1: Verify DNS Resolution
yaml- name: "Verify DNS record exists"
  ansible.builtin.shell: |
    nslookup landscap.poc.serpro || getent hosts landscap.poc.serpro
  register: dns_check
  ignore_errors: true

- name: "DNS Check Result"
  ansible.builtin.debug:
    msg: |
      {% if dns_check.rc == 0 %}
      ✅ DNS resolves landscap.poc.serpro
      {% else %}
      ⚠️  DNS not resolving. Ensure:
      1. DNS server has entry: landscap.poc.serpro → {{ landscape_ip.stdout }}
      2. Or add to /etc/hosts: {{ landscape_ip.stdout }} landscap.poc.serpro
      {% endif %}
Task 3.2: Update /etc/hosts (if needed)
yaml- name: "Add to /etc/hosts (local testing)"
  ansible.builtin.lineinfile:
    path: /etc/hosts
    regexp: "^.*landscap.poc.serpro$"
    line: "{{ landscape_ip.stdout }} landscap.poc.serpro"
    state: present
  become: yes
  when: dns_check.rc != 0

Fase 4: Access & Validation
Task 4.1: Get Access Information
yaml- name: "Gather Landscape access info"
  ansible.builtin.shell: |
    lxc exec landscape -- bash << 'EOF'
    LANDSCAPE_IP=$(hostname -I | awk '{print $1}')
    ADMIN_USER=$(grep "^admin" /etc/passwd 2>/dev/null | cut -d: -f1 || echo "admin")
    echo "IP: $LANDSCAPE_IP"
    echo "Admin User: $ADMIN_USER"
    systemctl status landscape-server | grep -E "active|failed"
    EOF
  become: yes
  register: landscape_info

- name: "Display Access Instructions"
  ansible.builtin.debug:
    msg: |
      🎉 Landscape Server Ready!
      
      Access Methods:
      
      1. Via FQDN (recommended):
         https://landscap.poc.serpro:6554
         
      2. Via IP:
         http://{{ landscape_ip.stdout }}:6554
         
      3. Via SSH to container:
         lxc exec landscape -- bash
         
      Port Forwarding Active:
      {{ port_forward_result.stdout }}
      
      Logs:
      - lxc exec landscape -- tail -f /var/log/landscape/django.log
      - lxc exec landscape -- tail -f /var/log/cloud-init-output.log
Task 4.2: Health Check
yaml- name: "Health check Landscape"
  ansible.builtin.shell: |
    lxc exec landscape -- bash << 'EOF'
    echo "=== System Status ==="
    systemctl status landscape-server --no-pager | head -5
    
    echo "=== Database Status ==="
    sudo -u postgres psql -d landscape -c "SELECT COUNT(*) FROM django_migrations;" 2>/dev/null || echo "DB initializing..."
    
    echo "=== Web Service ==="
    curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://localhost:6554/
    EOF
  become: yes
  register: health_check
  ignore_errors: true

- name: "Health Check Result"
  ansible.builtin.debug:
    msg: "{{ health_check.stdout_lines }}"

Fase 5: HA Scaling (Para Depois)
Future Task: Replicate to 3 Nodes
yaml# Quando landscape-1 estiver estável, crie:
# - landscape-2 (IP: .X+1)
# - landscape-3 (IP: .X+2)
# 
# Com replicação PostgreSQL entre os 3

- name: "Create HA cluster (future)"
  debug:
    msg: |
      TODO: Implement 3-node HA
      1. Clone landscape-1 → landscape-2, landscape-3
      2. Configure PostgreSQL replication
      3. Setup load balancer (HAProxy)
      4. Test failover scenarios

Instruções para AI Coder
Quando Executar
bash# Passo 1: Deploy Landscape
ansible-playbook playbooks/landscape-deploy-lxc.yml

# Passo 2: Verificar acesso
lxc list landscape --format=csv -c n,4

# Passo 3: Acessar
firefox http://landscap.poc.serpro:6554 &
Red Flags (Não fazer)

❌ NÃO instale via snap
❌ NÃO use SSH direto (use lxc exec)
❌ NÃO ignore cloud-init logs
❌ NÃO mude portas sem atualizar port forwarding

Green Lights (Fazer)

✅ Use cloud-init sempre
✅ Aguarde cloud-init completar (5-15 min)
✅ Verifique DNS antes de acessar FQDN
✅ Documente todos os IPs usados


Validação Final
bash# Tudo pronto quando:
✅ lxc list landscape mostra container rodando
✅ lxc exec landscape -- systemctl status landscape-server = active
✅ curl http://landscap.poc.serpro:6554 retorna HTTP 200
✅ Browser acessa https://landscap.poc.serpro:6554 sem erro SSL

Próximos Passos (Após MVP)

Replicação: 3 containers com PostgreSQL HA
Migração: De Ansible para Juju (se escalar)


Mantenha este documento atualizado com seus IPs reais.







## 1. Contexto Estratégico: Ansible + Juju (Duas Fases)

### Visão Geral
Este projeto implementa **alta disponibilidade para Landscape Server** em duas fases:

```
FASE 1 (Atual): Ansible/LXD MVP
├─ Objetivo: Landscape funcional em containers LXD
├─ Timeline: 2-4 semanas
├─ Responsabilidade: Ansible provisiona, você gerencia
└─ Saída: Landscape HA local, testado
```

```
FASE 2 (Futuro): Juju HA Production
├─ Objetivo: Landscape auto-gerenciado e multi-cloud
├─ Timeline: 2-6 meses depois
├─ Responsabilidade: Juju gerencia, você monitora
└─ Saída: Landscape portable, resiliente, escalável
```

### Por que duas fases?

**Fase 1 (Ansible/LXD):**
- ✅ Valida Landscape funciona rapidamente
- ✅ Você aprende operações em ambiente controlado
- ✅ Infraestrutura LXD é reutilizável para Juju depois
- ✅ Baixo custo de infraestrutura
- ❌ Mais trabalho operacional manual

**Fase 2 (Juju):**
- ✅ Auto-healing e rolling updates automáticos
- ✅ Multi-cloud portabilidade (AWS, Azure, MAAS, LXD, Kubernetes)
- ✅ MTTR reduzido em ~70% (18 min vs 55 min)
- ✅ Escalabilidade declarativa
- ❌ Curva de aprendizado, refatoração de operações

### Ponto de Decisão: Quando Migrar para Juju?

Migre quando:
- [ ] Landscape está estável em produção por 3+ meses
- [ ] Precisa de multi-cloud (AWS, Azure, on-prem)
- [ ] Equipe SRE quer reduzir MTTR abaixo de 20 min
- [ ] Precisa escalar para 50+ máquinas
- [ ] Budget permite investimento em learn curve

Mantenha Ansible/LXD se:
- [ ] Infraestrutura local apenas
- [ ] 3-5 máquinas máximo
- [ ] Team pequena, flexibilidade importante
- [ ] Deploy one-shot (não precisa auto-update)

---

## 2. Arquitetura Atual: Ansible/LXD (Fase 1)

### Stack Técnico
```
┌─────────────────────────────────────────┐
│ Local Machine (seu laptop/workstation)  │
│ ├─ Ansible (orchestration)              │
│ ├─ sshpass (password auth)              │
│ └─ ANSIBLE_HOST_KEY_CHECKING=False      │
└─────────────────────────────────────────┘
            SSH (port 22)
                  ↓
┌─────────────────────────────────────────┐
│ LXD Host (landscape-node1)              │
│ └─ LXD Daemon                           │
└─────────────────────────────────────────┘
            lxc exec
                  ↓
┌─────────────────────────────────────────┐
│ LXD Containers (rede 192.168.1.0/24)    │
│ ├─ ha-node-01 (Landscape + PostgreSQL)  │
│ ├─ ha-node-02 (Landscape + PostgreSQL)  │
│ └─ ha-node-03 (Monitor/Load Balancer)   │
└─────────────────────────────────────────┘
```

### Fluxo de Automação

1. **00-create-containers.yml** (Provisionamento)
   - Delete containers antigos
   - Criar 3 containers Ubuntu 22.04
   - Ativar SSH com password auth
   - Criar rede interna LXD (192.168.1.0/24)
   - Gerar inventário dinâmico com IPs

2. **00-prepare-nodes.yml** (Preparação)
   - Instalar dependências (git, curl, python3, ansible)
   - Configurar rede e storage
   - Instalar Juju (para Fase 2)

3. **01-bootstrap-controller.yml** (Deploy Landscape)
   - Instalar Landscape Server
   - Configurar PostgreSQL
   - Setup replicação HA
   - Validar health checks

### Limitações Conhecidas (Ansible/LXD)

| Aspecto | Limitação | Workaround |
|---------|-----------|-----------|
| Auto-healing | Manual | Scripts de health check + cron |
| Rolling updates | Manual | Blue-green deployment via playbook |
| Multi-cloud | Não | Refazer playbooks por cloud |
| Escalabilidade | ~20 máquinas | Depois migra para Juju |
| MTTR | 25-55 min | Melhora quando migra para Juju |

---

## 3. Filosofia de Engenharia: DevOps/SRE

### Princípios Guia

**1. Infrastructure as Code**
- Tudo em git (playbooks, inventários, configs)
- Nada configurado manualmente
- Auditoria completa de mudanças

**2. Declarativo > Imperativo**
- Descrever o estado desejado (Juju, Terraform)
- Evitar scripts imperativos (shell loops)
- Exception: Ansible é imperativo, mas organizado

**3. Operações Sustentáveis**
- MTTR < 20 minutos (SRE OKR)
- Auto-healing onde possível
- Monitoring + alerting desde o início

**4. Reutilização e Portabilidade**
- Containers LXD funcionam em Ansible e Juju
- Playbooks migram para Terraform/Helm depois
- Nenhum trabalho é perdido

### Trade-offs Aceitos

```
Ansible/LXD (Fase 1):
├─ Ganho: Velocidade, simplicidade, flexibilidade
├─ Custo: Mais trabalho operacional manual
└─ Aceitável: Curto prazo até Fase 2
```

```
Juju (Fase 2):
├─ Ganho: Auto-healing, escalabilidade, multi-cloud
├─ Custo: Aprendizado, refatoração
└─ Justificado: Quando produção precisa stabilidade
```

---

## 4. Workflow de Desenvolvimento

### Checklist: Antes de Executar Playbooks

- [ ] IPs em `inventory/ha-test.ini` estão atualizados
- [ ] SSH funciona: `ssh -o StrictHostKeyChecking=no root@IP`
- [ ] Containers estão online: `lxc list`
- [ ] LXD network existe: `lxc network show lxdbr0`
- [ ] `sshpass` está instalado: `which sshpass`
- [ ] `ANSIBLE_HOST_KEY_CHECKING=False` está exportado

### Execução Ordem-Correta

```bash
# Passo 1: Provisionar containers e gerar inventário
sudo ansible-playbook playbooks/00-create-containers.yml

# Passo 2: Preparar nós (dependências, Juju)
export ANSIBLE_HOST_KEY_CHECKING=False
ansible-playbook -i inventory/ha-test.ini playbooks/00-prepare-nodes.yml

# Passo 3: Deploy Landscape e HA
ansible-playbook -i inventory/ha-test.ini playbooks/01-bootstrap-controller.yml

# Passo 4: Validar
ansible-playbook -i inventory/ha-test.ini playbooks/tests/health-check.yml
```

### Troubleshooting Prioridade

| Erro | Diagnóstico | Solução |
|------|-------------|---------|
| `Permission denied (publickey)` | SSH config incorreta | `lxc exec ha-node-X -- grep PasswordAuthentication /etc/ssh/sshd_config` |
| `subnet X not found` | Rede LXD não criada | `lxc network create lxdbr0 ipv4.address=192.168.1.1/24` |
| `couldn't resolve module` | Collection não instalada | `ansible-galaxy collection install community.general --force` |
| `UNREACHABLE` | Inventário desatualizado | Rerun `00-create-containers.yml` |

---

## 5. KPIs e Métricas de Sucesso

### Fase 1 (Ansible/LXD) - Sucesso é:
- [ ] Landscape acessível em `https://ha-node-01`
- [ ] PostgreSQL replicado entre 3 nós
- [ ] Database failover < 5 minutos
- [ ] Health checks passam 99%+ da semana
- [ ] MTTR < 30 minutos (manual intervention)

### Fase 2 (Juju) - Sucesso é:
- [ ] Mesmos KPIs acima
- [ ] MTTR < 10 minutos (Juju auto-healing)
- [ ] Rolling updates sem downtime
- [ ] Charm deployable em AWS + Azure + MAAS
- [ ] Auto-scaling funciona

---

## 6. Instruções para Assistente de IA

### Quando Ajudar com Playbooks:
1. Mantenha esta estratégia de duas fases em mente
2. Priorize Fase 1 (Ansible) até tudo estável
3. Não use Juju ou Terraform agora (premature optimization)
4. Foque em MTTR e operações sustentáveis

### Quando Questionar:
- "Isso é melhor em Juju?" → Talvez, mas guarda para Fase 2
- "Por que não Kubernetes?" → Multi-cloud pronto, mas overengineer agora
- "Por que LXD e não Docker?" → LXD melhor para VMs, Juju suporta

### Red Flags que Ignorar:
- ❌ "Seu Ansible é complexo" → Esperado em produção
- ❌ "Deveria usar Helm" → Prematuro, Docker ainda não
- ❌ "Juju é overkill" → Verdadeiro agora, essencial depois

### Green Lights que Reforçar:
- ✅ "IaC tudo em git" → Sim!
- ✅ "Containers LXD reutilizáveis" → Estratégia inteligente
- ✅ "Ansible → Juju migration path" → Exato!

---

## 7. Documentação de Referência

### Cheat Sheet: Operações Diárias

```bash
# Ver status dos containers
lxc list --format=csv -c n,s,4

# SSH em um container
ssh -o StrictHostKeyChecking=no root@IP

# Executar playbook (não esqueça ANSIBLE_HOST_KEY_CHECKING)
export ANSIBLE_HOST_KEY_CHECKING=False
ansible-playbook -i inventory/ha-test.ini playbooks/PLAYBOOK.yml

# Health check manual
ansible-playbook -i inventory/ha-test.ini playbooks/tests/health-check.yml

# Provisionar novamente (limpo)
sudo ansible-playbook playbooks/00-create-containers.yml
```

### Links Úteis
- Juju Documentation: https://juju.is/docs
- Ansible Best Practices: https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html
- LXD Networking: https://linuxcontainers.org/lxd/docs/master/networks/
- Landscape Server: https://landscape.canonical.com/

---

## 8. Roadmap: Próximas Ações

### Semana 1-2 (Fase 1 Finalizar)
- [ ] Finish Ansible playbooks para Landscape
- [ ] Validar 3-nó cluster estável
- [ ] Documentar runbooks operacionais
- [ ] Setup monitoring (Prometheus/Grafana optional)

### Semana 3-4 (Produção Local)
- [ ] Deploy em ambiente "produção local"
- [ ] Executar testes de stress (failover, updates)
- [ ] Ajustar MTTR goals
- [ ] Treinar equipe SRE

### Mês 2-3 (Avaliar Juju)
- [ ] Começar estudo de Juju paralelo (não blocking)
- [ ] Criar POC com Juju charm simples
- [ ] Planejar migration path
- [ ] Orçar tempo/esforço para Fase 2

### Mês 3+ (Fase 2: Juju HA)
- [ ] Migrar Landscape para Juju
- [ ] Testar multi-cloud (AWS, Azure)
- [ ] Implementar auto-healing
- [ ] Reduzir MTTR abaixo de 10 min

---

## Conclusão

Este projeto é um **exemplo de engenharia pragmática**: não é "tudo ou nada" com Juju, é **iterativo e validado**.

Fase 1 entrega valor real (Landscape HA) enquanto prepara groundwork para Fase 2 (Juju HA). Nenhum trabalho é perdido, e você aprende no ritmo certo.

Mantenha esta estratégia clara, e o projeto será um sucesso operacional.
